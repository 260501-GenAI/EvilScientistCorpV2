from typing import TypedDict, Any


# This service will define the State, Nodes, and Graph for our LangGraph implementation


# First, we'll define the State of our Graph
# You can think of State like a container for global data. The "state" of the app.
# Each Node in the Graph can read from and write to State
# This class syntax makes GraphState a subclass of TypedDict with params
class GraphState(TypedDict, total=False): #total=False makes all fields optional
    # The most recent user query
    query: str

    # The "routing decision" we make. This tells the app what node to invoke next
    route: str

    # Any retrieved documents from the Vector DB
    docs: list[dict[str, Any]]

    # The most recent answer generated by the LLM
    answer: str


# ==============================(NODE DEFINITIONS)===============================

# Notice each node takes in graph state AND returns graph state
# Nodes have access to the entire state AND can modify it

# The Route Node - decides what node to invoke based on the user's query
# This is a very user-facing node. It's the first node to read the user's query
def route_node(state: GraphState) -> GraphState:

    # Get the user's query, turn it to lowercase for each of keyword matchin
    query = state.get("query", "").lower()
    # WHAT is this?^ We're getting the user's query out of the state "query" field
    # How does state already know what the query is??
    # The user's query gets passed in when the graph is invoked and GraphState is initialized

    # VERY basic keyword matching (for now) to decide which node to invoke next
    # TODO: Use the LLM to decide which node to invoke instead of using hardcoded keyword matching
    if any(word in query for word in ["item", "items", "product", "buy", "purchase"]):
        return {"route":"items"} # This return adds the route to State!

    if any(word in query for word in ["boss", "boss's", "plan", "plans", "scheme", "schemes"]):
        return {"route":"plans"} # This return adds the route to State!

    # TODO: default chat node if routes are identified


# =========================(END OF NODE DEFINITIONS)=============================


# Define the function that builds and returns the graph
# In our endpoint, we'll invoke the graph, not the LLM directly, definitely not a chain
def build_graph():
    pass